# RFC RateLimitPolicy v2

- Feature Name: `rlp-v2`
- Start Date: (fill me in with today's date, YYYY-MM-DD)
- RFC PR: [Kuadrant/architecture#0000](https://github.com/Kuadrant/architecture/pull/0000)
- Issue tracking: [Kuadrant/architecture#0000](https://github.com/Kuadrant/architecture/issues/0000)

## Summary
[summary]: #summary

Proposal of new API for the Kuadrant's `RateLimitPolicy` (RLP) CRD, for improved UX.

### Motivation
[motivation]: #motivation

The [`RateLimitPolicy`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#RateLimitPolicy) API (v1beta1), particularly its [`RateLimit`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#RateLimit) type used in `ratelimitpolicy.spec.rateLimits`, designed in part to fit the underlying implementation based on the Envoy [Rate limit](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter) filter, has been proven to be (i) _unnecessarily complex_, as well as (ii) possibly _limiting for the extension of the API_ either beyond this specific implementation and/or for supporting use cases of rate limiting not contemplated in the original designs.

Users of the `RateLimitPolicy` will immediately recognize elements of Envoy's Rate limit API in the definitions of the `RateLimit` type, with almost 1:1 correspondence between the [`Configuration`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#Configuration) and [`Rule`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#Rule) types and their counterparts in the Envoy configuration. Although compatibility between those continue to be desired, the leakage of such implementation details to the level of the API could otherwise be avoided to provide a better abstraction for the context in vogue, where activators ("matchers") and payload ("descriptors") are defined by users in a same document instead of in different configurations of different components.

Furthermore, the also related [`Limit`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#Limit) type ‚Äì used as well in the `RateLimitPolicy`'s `RateLimit` ‚Äì implies presently a logical relationship between its inner concepts ‚Äì i.e. conditions and variables on one side, and limits themselves on the other ‚Äì that otherwise could be shaped in a different manner, to provide (i) clearer understanding of the meaning of these concepts by the user as well as (ii) to avoid repetition.

### Goals

1. Decouple the API from the underlying implementation - i.e. provide a more generic and more user-friendly abstraction
2. Simplify the API - i.e. DRY, straight to the point (for defining rate limits)
3. Consistency with Kuadrant's [AuthPolicy](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#AuthPolicy) API - i.e. same language, similar UX

### Current WIP to consider

1. A single Policy scoped to HTTPRoutes and HTTPRouteRule (https://github.com/Kuadrant/architecture/pull/4)
2. Implement `skip_if_absent` for the RequestHeaders action (https://github.com/Kuadrant/wasm-shim/issues/29)
3. Rate Limiting across clusters ([doc](https://docs.google.com/document/d/1pqCODRAkNUTLB6lJfRWcv3d2Hlj9WqsGySmjrP707Vk/edit#heading=h.nzpgr3pef6uy))

### Highlights

- `spec.rateLimits` replaced by `spec.limits`
- `spec.rateLimits.limits` replaced by `spec.limits.rates`
- `spec.rateLimits.limits.maxValue` replaced by `spec.limits.rates.limit`
- `spec.rateLimits.limits.seconds` replaced by `spec.limits.rates.duration` + `spec.limits.rates.unit`
- `spec.rateLimits.limits.conditions` replaced by `spec.limits.when`, structured field based on _well-known selectors_, mainly for expressing conditions not related to the HTTP route (although not exclusively)
- `spec.rateLimits.limits.variables` replaced by `spec.limits.counters`, based on _well-known selectors_
- `spec.rateLimits.rules` replaced by `spec.limits.matches`, where each match is a perfect match to one of the `HTTPRouteMatch`es of the targeted `HTTPRoute` (`httproute.spec.rules.matches`) ‚Äì complies with [architecture#4](https://github.com/Kuadrant/architecture/pull/4)
- `spec.rateLimits.configurations` removed ‚Äì `spec.rateLimits.configurations.actions` generated from `spec.limits.when.selector` ‚à™ `spec.limits.counters` and `spec.limits.matches`
- Limitador conditions composed of `spec.limits.when` + unique hash identifier - ensures the limit is enforced only for the targeted `HTTPRouteMatch`
- `spec.limits.increment` introduced

For detailed differences between current and vew RLP API, see [Comparison to current RateLimitPolicy](#comparison-to-current-ratelimitpolicy).

## Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

### Examples of RLPs based on the new API

Given the following network resources:

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: Gateway
metadata:
  name: istio-ingressgateway
  namespace: istio-system
spec:
  gatewayClassName: istio
  listeners:
    - hostname: "*.toystore.com"
---
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: HTTPRoute
metadata:
  name: toystore
  namespace: toystore
spec:
  parentRefs:
    - name: istio-ingressgateway
      namespace: istio-system
  hostnames: ["*.toystore.com"]
  rules:
    - matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
        - path:
            type: PathPrefix
            value: "/toys"
          method: POST
      backendRefs:
        - name: toystore
          port: 80
```

The following are examples of RLPs targeting the route and the gateway.

#### Example 1. Minimal example - network resource targeted entirely without filtering, unconditional and unqualified rate limiting

In this example, all traffic to `*.toystore.com` will be limited to 5 rps, unconditionally and regardless of path, method or any other attribute of the request, across all consumers of the API.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-simple-infra-rl
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - rates: # at least one rate limit required
        - limit: 5
          unit: second
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "e6064bc3504d2fbc972b3432bec494b3af8fb760e480ba42bb72c1574e57be07--toystore/toystore-simple-infra-rl/0"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "e6064bc3504d2fbc972b3432bec494b3af8fb760e480ba42bb72c1574e57be07--toystore/toystore-simple-infra-rl/0"
    max_value: 5
    seconds: 1
    namespace: "*.toystore.com"
  ```
</details>

#### Example 2. Specific route matching rule targeted, conditions, counter qualifiers and multiple rates

In this example, a distinct limit is associated to each individual matching rule of the targeted HTTPRoute, using the `matches` field for fine-grained filtering. In both cases, the rate limits are to be enforced per username and only in case the user is not an admin.

For each matching rule in the RLP, the RLP controller will try to find a matching rule in the HTTPRoute that is an identical match to it and bind the two matching rules together; the first identical match prevails. In case there is no identical match in the HTTPRoute, the RLP is considered invalid. In case there is more than one matching rule specified in the RLP that is an identical match to the same matching rule in the HTTPRoute, the first matching rule on the list in the RLP is bound to its identical match in the HTTPRoute, thus "shadowing" any other rule on the list that is also an identical match.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-per-endpoint-per-user
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: readers
      matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
      rates:
        - limit: 50
          duration: 1
          unit: minute
      counters:
        - auth.identity.username
      when:
        - selector: auth.identity.group
          operator: neq
          value: admin

    - name: writers
      matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: POST
      rates:
        - limit: 5
          duration: 1
          unit: minute
        - limit: 100
          duration: 12
          unit: hour
      counters:
        - auth.identity.username
      when:
        - selector: auth.identity.group
          operator: neq
          value: admin
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "2718701ec9bfd79132e58d92aed722489443094bf9c616e1b74361fe68360f05--toystore/toystore-per-endpoint-per-user/readers"
      - metadata:
          descriptor_key: "auth.identity.group"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "group"
      - metadata:
          descriptor_key: "auth.identity.username"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "username"
  - rules:
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "4f70fc57ad52a2664e3920f373633a9b2b2f4f58f17b39a8d3a3a3485fd91c4d--toystore/toystore-per-endpoint-per-user/writers"
      - metadata:
        descriptor_key: "auth.identity.group"
        metadata_key:
          key: "envoy.filters.http.ext_authz"
          path:
            - segment:
                key: "identity"
            - segment:
                key: "group"
      - metadata:
          descriptor_key: "auth.identity.username"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "username"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "2718701ec9bfd79132e58d92aed722489443094bf9c616e1b74361fe68360f05--toystore/toystore-per-endpoint-per-user/readers"
      - auth.identity.group != "admin"
    variables:
      - auth.identity.username
    max_value: 50
    seconds: 60
    namespace: "*.toystore.com"
  - conditions:
      - context.request.http.route_matcher == "4f70fc57ad52a2664e3920f373633a9b2b2f4f58f17b39a8d3a3a3485fd91c4d--toystore/toystore-per-endpoint-per-user/writers"
      - auth.identity.group != "admin"
    variables:
      - auth.identity.username
    max_value: 5
    seconds: 60
    namespace: "*.toystore.com"
  - conditions:
      - context.request.http.route_matcher == "4f70fc57ad52a2664e3920f373633a9b2b2f4f58f17b39a8d3a3a3485fd91c4d--toystore/toystore-per-endpoint-per-user/writers"
      - auth.identity.group != "admin"
    variables:
      - auth.identity.username
    max_value: 100
    seconds: 43200 # 12 hours
    namespace: "*.toystore.com"
  ```
</details>

#### Example 3. Route filtering using `when` conditions

`when` conditions are preferably to be used for special cases of conditional filtering based on values other than attributes of the route that could otherwise be specified using the `matches` field. However, in some cases such as where the condition is not related to the HTTPRoute (e.g. see [Example 2](#example-2-specific-route-matching-rule-targeted-conditions-counter-qualifiers-and-multiple-rates) above; filterring based on hostname, etc) or a temporary measure while the target object misses the desired matching rule, the `when` conditions remains an option.

In this example, a special limit with one rate limit of 150 rps is set for `GET` requests to the `/toys/special` path. Because the `toystore` HTTPRoute is unaltered, the special case is defined using the `when` conditions field.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-special-toys
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: read-special
      matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
      rates:
        - limit: 150
          unit: second
      when:
        - selector: context.request.http.path
          operator: eq
          value: /toys/special
```

By using the route rule as-is, simply `GET /toys*` instead of more specific `GET /toys/special`, the rate limit filter (wasm filter) will continue invoking the rate limit service (Limitador) for all requests that match HTTP method equal to `GET` and path prefix equal to `/toys`, including requests to paths other than `/toys/special`, but the limit will only be enforced when the path fully matches `/toys/special`, as specified in the `when` condition.

On one hand, this makes it easy to set limits when either the HTTPRoute cannot be modified to include a special matching rule or as a shortcut in cases where multiple HTTPRoutes would have to be touched, such when targeting a Gateway with special conditions based on attributes of the route. On the other hand however, users might miss information in the status in a scenario where the status of rate limiting is reported at the level of the route rule or rule matcher. Effectively, the route rule `GET /toys*` might be reported as rate limited to '150 rps' when that is actually only the case of requests to `GET /toys/special`. These special conditions of the limit definition need therefore to be included in the status.

In the case of existing other limit definitions targeting the `GET /toys*` matching rule of the `toystore` HTTPRoute, because a merge strategy is expect to take into account the `matches` field as part of the qualification of the limit, there should be no problem of multiple simultaneous limits enforced to the same route rules, differenciated only by special conditions. Nevertheless, to avoid dealing of complex status reports including too many special conditions associated with a limit, users are instead encouraged to favor altering the HTTPRoutes for additional route rules that can be referred in the `matches` field preferably.

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "2718701ec9bfd79132e58d92aed722489443094bf9c616e1b74361fe68360f05--toystore/toystore-special-toys/read-special"
      - request_headers:
          descriptor_key: "context.request.http.path"
          header_name: ":path"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "2718701ec9bfd79132e58d92aed722489443094bf9c616e1b74361fe68360f05--toystore/toystore-special-toys/read-special"
      - context.request.http.path == "/toys/special"
    max_value: 150
    seconds: 1
    namespace: "*.toystore.com"
  ```
</details>

#### Example 4. Route filtering by refining the HTTPRoute

To achieve the same goal as state in [Example 3](#example-3-route-filtering-using-when-conditions) yet ensuring proper merging of conflicting limits that target the same high-level route rule and simpler status report without additional condition associated with the limit, this example RLP is preceded by a change in the HTTPRoute. A new matching rule is added for the `GET /toys/special` case so it can be targeted by the policy using the `matches` field instead of the `when` conditions field.

New matching rule added to the HTTPRoute:

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: HTTPRoute
metadata:
  name: toystore
  namespace: toystore
spec:
  parentRefs:
    - name: istio-ingressgateway
      namespace: istio-system
  hostnames: ["*.toystore.com"]
  rules:
    - matches:
        - path: # new matching rule added so it can be targeted by the RLP
            type: Exact
            value: "/toys/special"
          method: GET
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
        - path:
            type: PathPrefix
            value: "/toys"
          method: POST
      backendRefs:
        - name: toystore
          port: 80
```

RateLimitPolicy:

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-special-toys
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: read-special
      matches:
        - path:
            type: Exact
            value: "/toys/special"
          method: GET
      rates:
        - limit: 150
          unit: second
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys/special"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "d6f67e4a75c1f4a9b8030b4939d2c1bdf13f2c86493a71de25e33c3748fc0d3c--toystore/toystore-special-toys/0"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "d6f67e4a75c1f4a9b8030b4939d2c1bdf13f2c86493a71de25e33c3748fc0d3c--toystore/toystore-special-toys/0"
    max_value: 150
    seconds: 1
    namespace: "*.toystore.com"
  ```
</details>

#### Example 5. One limit, two matches

In this example, both route matching rules, `GET /toys*` and `POST /toys*`, are targeted by the same limit. This will cause the limit to be bound to the two HTTPRouteMatches, effectively applying 50rpm per username, regardless of the HTTP method `GET` or `POST`, at requests with path prefix equal to `/toys`. I.e. the rules are OR'ed, just like in the HTTPRoute itself. The same unique hash identifier is associated to both route rules.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-per-endpoint-per-user
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
        - path:
            type: PathPrefix
            value: "/toys"
          method: POST
      rates:
        - limit: 50
          duration: 1
          unit: minute
      counters:
        - auth.identity.username
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "e6064bc3504d2fbc972b3432bec494b3af8fb760e480ba42bb72c1574e57be07--toystore/toystore-per-endpoint-per-user/0"
      - metadata:
          descriptor_key: "auth.identity.username"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "username"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "e6064bc3504d2fbc972b3432bec494b3af8fb760e480ba42bb72c1574e57be07--toystore/toystore-per-endpoint-per-user/0"
    variables:
      - auth.identity.username
    max_value: 50
    seconds: 60
    namespace: "*.toystore.com"
  ```
</details>

#### Example 6. Dynamic rate with flexible increments

By setting the increment of the limit, the rate can vary with no need to reset the counters.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-dynamic
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: dynamic-rate
      rates:
        - limit: 100
          unit: second
      increment:
        value: 2 # each hit artificially made twice as expensive without reseting the counters
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "e6064bc3504d2fbc972b3432bec494b3af8fb760e480ba42bb72c1574e57be07--toystore/toystore-dynamic/0"
      - hits_addend: 2 # Not implemented - see https://github.com/envoyproxy/envoy/issues/12969
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "e6064bc3504d2fbc972b3432bec494b3af8fb760e480ba42bb72c1574e57be07--toystore/toystore-dynamic/0"
    max_value: 5
    seconds: 1
    namespace: "*.toystore.com"
    increment: <rlq.hits_addend | 2> # Not implemented
  ```
</details>

#### Example 7. Targeting the Gateway

Targeting a Gateway is a shortcut to targeting individually each HTTPRoute pointing to the gateway, without any filtering based on the `matches` field.

> **Note:** it is hard to give any additional meaning and context to this without going into [defaults and overrides](https://gateway-api.sigs.k8s.io/references/policy-attachment/#hierarchy).

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-simple-infra-rl
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: Gateway
    name: istio-ingressgateway
  limits:
    - rates:
        - limit: 5
          unit: second
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "e6064bc3504d2fbc972b3432bec494b3af8fb760e480ba42bb72c1574e57be07--toystore/toystore-simple-infra-rl/0"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "e6064bc3504d2fbc972b3432bec494b3af8fb760e480ba42bb72c1574e57be07--toystore/toystore-simple-infra-rl/0"
    max_value: 5
    seconds: 1
    namespace: "*.toystore.com"
  ```
</details>

### Comparison to current RateLimitPolicy

<table>
  <thead>
    <tr>
      <th>Current</th>
      <th>New</th>
      <th>Reason</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1:1 relation between <i>Limit</i> (the object) and the actual <i>Rate limit</i> (the value) (<code>spec.rateLimits.limits</code>)</td>
      <td><i>Rate limit</i> becomes a detail of <i>Limit</i> where each limit may define one or more rates (1:N) (<code>spec.limits.rates</code>)</td>
      <td>
        <ul>
          <li>It allows to reuse <code>when</code> conditions and <code>counters</code> for <i>groups of rate limits</i></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Parsed <code>spec.rateLimits.limits.conditions</code> field, directly exposing the Limitador's API</td>
      <td>Structured <code>spec.limits.when</code> condition field composed of 3 well-defined properties: <code>selector</code>, <code>operator</code> and <code>value</code></td>
      <td>
        <ul>
          <li>Feels more K8s-native</li>
          <li>Consistent with <a href="https://pkg.go.dev/github.com/kuadrant/authorino/api/v1beta1#JSONPatternExpression">github.com/kuadrant/authorino/api/v1beta1#JSONPatternExpression</a></li>
          <li>No need for a parser (only if implemented by Limitador)</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.configurations</code> as a list of "variables assignments" and direct exposure of <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter#composing-actions">Envoy's RL descriptor actions API</a></td>
      <td>Descriptor actions composed implicitly from selectors used in the limit definitions (<code>spec.limits.when.selector</code> and <code>spec.limits.counters</code>) plus a fixed identifier of the route rule (<code>spec.limits.matches</code>)</td>
      <td>
        <ul>
          <li>Abstract the Envoy-specific concepts of "actions" and "descriptors"</li>
          <li>No risk of mismatching descriptors keys between "actions" and actual usage in the limits</li>
          <li>No user-defined generic descriptors (e.g. "limited = 1")</li>
          <li>Source value of the selectors defined from an implicit "context" data structure</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Key-value descriptors</td>
      <td>Structured descriptors referring to a contextual well-known data structure</td>
      <td>
        <ul>
          <li>Consistent with Authorino's <a href="https://github.com/Kuadrant/authorino/blob/main/docs/architecture.md#the-authorization-json">Authorization JSON (#context)</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Limitador conditions independent from the route rules</td>
      <td>Artificial Limitador condition injected for each route match</td>
      <td>
        <ul>
          <li>Ensure the limit is enforced only for corresponding filtered HTTPRouteMatch</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.rules ‚äÜ httproute.spec.rules</code></a></td>
      <td><code>spec.limits.matches ‚àä httproute.spec.rules.matches</code></td>
      <td>
        <ul>
          <li>Perfect match to HTTPRoute matching rules</li>
          <li>Simpler to solve for defaults and overrides</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.limits.seconds</code></td>
      <td><code>spec.limits.rates.duration</code> and <code>spec.limits.rates.unit</code></td>
      <td>
        <ul>
          <li>Support for more units beyond seconds</li>
          <li><code>duration: 1</code> by default</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.limits.variables</code></td>
      <td><code>spec.limits.counters</code></td>
      <td>
        <ul>
          <li>Less generic naming</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.limits.maxValue</code></td>
      <td><code>spec.limits.rates.limit</code></td>
      <td>
        <ul>
          <li>More generic naming</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Fixed implicit increment of 1</td>
      <td><code>spec.limits.increment: {}</code></td>
      <td>
        <ul>
          <li>Flexibility to change the limits without reseting the counters</li>
          <li>Placeholder for more complex RL systems in the future ‚Äì e.g. dynamic-RL, %, ùëì(), etc</li>
          <li>Migration path from other RL solutions, e.g. 3scale (?)</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

## Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

By completely dropping out the `configurations` field from the RLP, [composing the RL descriptor actions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter#composing-actions) is now done based essentially on the selectors listed in the `when` conditions and the `counters`, plus artificial generic conditions used to match the specific route rule (when `matches` is specified).

### Well-known selectors

Each selector is a direct reference to a path within a well-known data structure that holds the `context` (L4 and L7 data of the original request handled by the proxy), as well as occasionally the `auth` data (dynamic metadata exported by the external authorization filter and injected by the proxy into the rate-limit filter).

The well-known data structure for building RL descriptor actions resembles Authorino's ["Authorization JSON"](https://github.com/Kuadrant/authorino/blob/main/docs/architecture.md#the-authorization-json), whose `context` component consists of Envoy's [`AttributeContext`](https://pkg.go.dev/github.com/envoyproxy/go-control-plane/envoy/service/auth/v3?utm_source=gopls#AttributeContext) type of the external authorization API, marshalled as JSON. Compared to the more generic [`RateLimitRequest`](https://pkg.go.dev/github.com/envoyproxy/go-control-plane@v0.11.0/envoy/service/ratelimit/v3#RateLimitRequest) struct, the `AttributeContext` provides a more structured and arguibly more intuitive relation between the data sources for the RL descriptors actions and their corresponding key names through which the values are referred within the RLP, in a context of serving predominantly for HTTP-based APIs.

To keep compatibility with the [Envoy Rate Limit protocol](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter), the well-known data structure can optionally be extended with the `RateLimitRequest`, thus resulting in the following final structure.

```yaml
context: # Envoy's Ext-Authz `CheckRequest.AttributeContext` type
  source:
    address: ‚Ä¶
    service: ‚Ä¶
    ‚Ä¶
  destination:
    address: ‚Ä¶
    service: ‚Ä¶
    ‚Ä¶
  request:
    http:
      host: ‚Ä¶
      path: ‚Ä¶
      method: ‚Ä¶
      headers: {‚Ä¶}

  auth: # Dynamic metadata exported by the external authorization service

  ratelimit: # Envoy's Rate Limit `RateLimitRequest` type
    domain: ‚Ä¶ # generated by the Kuadrant controller
    descriptors: {‚Ä¶} # descriptors configured by the user directly in the proxy (not generated by the Kuadrant controller, if allowed)
    hitsAddend: ‚Ä¶ # only in case we want to allow users to refer to this value in a policy
```

### Mechanics of generating RL descriptor actions

From the perspective of a user who writes a RLP, the selectors used in then `when` and `counters` fields are paths to the well-known data structure ([_well-known selectors_](#well-known-selectors)). While desiging a policy, the user intuitively pictures the well-known data structure and designs each rule (each limit) thinking on the possible values assumed by each of those paths in the data plane. For example,

The user story:
> _Whenever the context is an HTTP request sent to `dolls.toystore.com` (`context.request.http.host`), I want a rate limit of 50 rps per distinct user (`auth.identity.username`)._

Materializes as the following RLP:

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: toys-path
      when:
        - selector: context.request.http.host
          operator: eq
          value: dolls.toystore.com
      rates:
        - limit: 50
          duration: 1
          unit: second
      counters:
        - auth.identity.username
```

The following selectors are to be interpreted:
- `context.request.http.host`
- `auth.identity.username`

The RLP controller uses a map to translate each selector into its corresponding descriptor action. Roughly described:

```
context.source.address    ‚Üí source_cluster(...) # TBC
context.source.service    ‚Üí source_cluster(...) # TBC
context.destination...    ‚Üí destination_cluster(...)
context.destination...    ‚Üí destination_cluster(...)
context.request.http.<X>  ‚Üí request_headers(header_name: ":<X>")
context.request...        ‚Üí ...
auth.<X>                  ‚Üí metadata(key: "envoy.filters.http.ext_authz", path: <X>)
ratelimit.domain          ‚Üí <hostname>
```

...to yield effectively:

```yaml
rate_limits:
  - actions:
      - request_headers:
          descriptor_key: "context.request.http.host"
          header_name: ":host"
      - metadata:
          descriptor_key: "auth.identity.username"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "username"
```

### Artificial Limitador condition for `matches`

For each limit, the RLP controller will generate an artificial Limitador condition that ensures that the limit applies only when that one filterred matching rule is honoured to serve the request. This can be implemented with a 2-step procedure:
1. generate an unique identifier for the limit ‚Äì e.g. by applying any sufficiently entropic hash function of choice to the `matches` block of the limit;
2. associate a `generic_key` type descriptor action to the each `HTTPRouteMatch` targeted by the limit.

For example, given the following RLP ([Example 2](#example-2-specific-route-matching-rule-targeted-conditions-counter-qualifiers-and-multiple-rates)):

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-non-admin-users
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: readers
      matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
      rates:
        - limit: 50
          duration: 1
          unit: minute
      when:
        - selector: auth.identity.group
          operator: neq
          value: admin

    - name: writers
      matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: POST
      rates:
        - limit: 5
          duration: 1
          unit: minute
      when:
        - selector: auth.identity.group
          operator: neq
          value: admin
```

Apart from the descriptor action (associated with both routes):

```yaml
- metadata:
    descriptor_key: "auth.identity.group"
    metadata_key:
      key: "envoy.filters.http.ext_authz"
      path:
        - segment:
            key: "identity"
        - segment:
            key: "group"
```

...and its corresponding Limitador condition:

```
auth.identity.group != "admin"
```

The following additional artificial descriptor actions will be generated:

```yaml
# associated with route GET /toys*
- generic_key:
    descriptor_key: "context.request.http.route_matcher"
    descriptor_value: "2718701ec9bfd79132e58d92aed722489443094bf9c616e1b74361fe68360f05" # SHA256 hashing of [{"path":{"type":"PathPrefix","value":"/toys"},"method":"GET"}]

# associated with route POST /toys*
- generic_key:
    descriptor_key: "context.request.http.route_matcher"
    descriptor_value: "4f70fc57ad52a2664e3920f373633a9b2b2f4f58f17b39a8d3a3a3485fd91c4d" # SHA256 hashing of [{"path":{"type":"PathPrefix","value":"/toys"},"method":"POST"}]
```

...and their corresponding Limitador conditions.

In the end, the following Limitador configuration is yielded:

```yaml
- conditions:
    - context.request.http.route_matcher == "2718701ec9bfd79132e58d92aed722489443094bf9c616e1b74361fe68360f05"
    - auth.identity.group != "admin"
  max_value: 50
  seconds: 60
  namespace: "*.toystore.com"

- conditions:
    - context.request.http.route_matcher == "4f70fc57ad52a2664e3920f373633a9b2b2f4f58f17b39a8d3a3a3485fd91c4d"
    - auth.identity.group != "admin"
  max_value: 5
  seconds: 60
  namespace: "*.toystore.com"
```

To improve readability, the unique hash identifiers can be suffixed with a plain identifier of the RLP itself (namespace and name) and the limit (limit name when available, limit index otherwise). E.g.: the two unique identifiers from above could become respectively `2718701ec9bfd79132e58d92aed722489443094bf9c616e1b74361fe68360f05--toystore/toystore-non-admin-users/readers` and `4f70fc57ad52a2664e3920f373633a9b2b2f4f58f17b39a8d3a3a3485fd91c4d--toystore/toystore-non-admin-users/writers`.

## Drawbacks
[drawbacks]: #drawbacks

**Two types of conditions ‚Äì `matches` and `when` conditions**<br/>
Although with different meanings (evaluates in the gateway vs. evaluated in Limitador) and capable of expressing different sets of rules (HTTPRouteMatch-related rules vs. HTTP request-related and non HTTP request-related rules), an overlap between these two types and ways of representing conditions does exist.

**Prone to consistency issues**<br/>
Typos and updates to the HTTPRoute can easily cause a mismatch and invalidate a RLP.

## Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

### Possible variations for the selectors (conditions and counter qualifiers)

The main drivers behind the proposed design for the selectors (conditions and counter qualifiers), based on (i) structured condition expressions composed of fields `selector`, `operator`, and `value`, and (ii) `when` conditions and `counters` separated in two distinct fields (variation "C" below), are:
1. consistency with the Authorino `AuthConfig` API, which also specifies [`when`](https://github.com/Kuadrant/authorino/blob/main/docs/features.md#common-feature-conditions-when) conditions expressed in `selector`, `operator`, and `value` fields;
2. explicit user intent, without subtle distinction of meaning based on presence of optional fields.

Nonetheless here are a few alternative variations to consider:

<table>
  <thead>
    <tr>
      <th></th>
      <th>Structured condition expressions</th>
      <th>Parsed condition expressions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Single field</th>
      <td>
        <b>A</b>
        <pre>
selectors:
  - selector: context.request.http.method
    operator: eq
    value: GET
  - selector: auth.identity.username</pre>
      </td>
      <td>
        <b>B</b>
        <pre>
selectors:
  - context.request.http.method == "GET"
  - auth.identity.username</pre>
      </td>
    </tr>
    <tr>
      <th>Distinct fields</th>
      <td>
        <b>C <sup>‚≠êÔ∏è</sup></b>
        <pre>
when:
  - selector: context.request.http.method
    operator: eq
    value: GET
counters:
  - auth.identity.username</pre>
      </td>
      <td>
        <b>D</b>
        <pre>
when:
  - context.request.http.method == "GET"
counters:
  - auth.identity.username</pre>
      </td>
    </tr>
  </tbody>
</table>

<sup>‚≠êÔ∏è Variation adopted for the <a href="#examples-of-rlps-based-on-the-new-api">examples</a> and (so far) final design proposal.</sup>

## Prior art
[prior-art]: #prior-art

<!-- Discuss prior art, both the good and the bad, in relation to this proposal.
A few examples of what this can include are:

- Does another project have a similar feature?
- What can be learned from it? What's good? What's less optimal?
- Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.

This section is intended to encourage you as an author to think about the lessons from other tentatives - successful or not, provide readers of your RFC with a fuller picture.

Note that while precedent set by other projects is some motivation, it does not on its own motivate an RFC. -->

[TODO]

## Unresolved questions
[unresolved-questions]: #unresolved-questions

1. What does this mean with _defaults_ and _overrides_?
2. Do we need anything here that points to shared counters across clusters/Limitador instances or does that belong to different layer (`Limitador`, `Kuadrant` CRDs, MCTC)?
3. What condition `operator`s do we need (e.g. `eq`, `neq`, `exists`, `nexists`, `matches`)?

## Future possibilities
[future-possibilities]: #future-possibilities

<!-- Think about what the natural extension and evolution of your proposal would be and how it would affect the platform and project as a whole. Try to use this section as a tool to further consider all possible interactions with the project and its components in your proposal. Also consider how this all fits into the roadmap for the project and of the relevant sub-team.

This is also a good place to "dump ideas", if they are out of scope for the RFC you are writing but otherwise related.

Note that having something written down in the future-possibilities section is not a reason to accept the current or a future RFC; such notes should be in the section on motivation or rationale in this or subsequent RFCs. The section merely provides additional information. -->

[TODO]
