# RFC RateLimitPolicy v2

- Feature Name: `rlp-v2`
- Start Date: 2023-02-02
- RFC PR: [Kuadrant/architecture#8](https://github.com/Kuadrant/architecture/pull/8)
- Issue tracking: N/A

## Summary
[summary]: #summary

Proposal of new API for the Kuadrant's `RateLimitPolicy` (RLP) CRD, for improved UX.

### Motivation
[motivation]: #motivation

The [`RateLimitPolicy`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#RateLimitPolicy) API (v1beta1), particularly its [`RateLimit`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#RateLimit) type used in `ratelimitpolicy.spec.rateLimits`, designed in part to fit the underlying implementation based on the Envoy [Rate limit](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter) filter, has been proven to be (i) _unnecessarily complex_, as well as (ii) possibly _limiting for the extension of the API_ either beyond this specific implementation and/or for supporting use cases of rate limiting not contemplated in the original designs.

Users of the `RateLimitPolicy` will immediately recognize elements of Envoy's Rate limit API in the definitions of the `RateLimit` type, with almost 1:1 correspondence between the [`Configuration`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#Configuration) and [`Rule`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#Rule) types and their counterparts in the Envoy configuration. Although compatibility between those continue to be desired, the leakage of such implementation details to the level of the API could otherwise be avoided to provide a better abstraction for the context in vogue, where activators ("matchers") and payload ("descriptors") are defined by users in a same document instead of in different configurations of different components.

Furthermore, the also related [`Limit`](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#Limit) type – used as well in the `RateLimitPolicy`'s `RateLimit` – implies presently a logical relationship between its inner concepts – i.e. conditions and variables on one side, and limits themselves on the other – that otherwise could be shaped in a different manner, to provide (i) clearer understanding of the meaning of these concepts by the user as well as (ii) to avoid repetition.

### Goals

1. Decouple the API from the underlying implementation - i.e. provide a more generic and more user-friendly abstraction
2. Simplify the API - i.e. DRY, straight to the point (for defining rate limits)
3. Consistency with Kuadrant's [AuthPolicy](https://pkg.go.dev/github.com/kuadrant/kuadrant-operator@v0.2.1/api/v1beta1#AuthPolicy) API - i.e. same language, similar UX

### Current WIP to consider

1. A single Policy scoped to HTTPRoutes and HTTPRouteRule ([architecture#4](https://github.com/Kuadrant/architecture/pull/4))
2. *No* merging of policies ([architecture#10](https://github.com/Kuadrant/architecture/pull/10))
3. Implement `skip_if_absent` for the RequestHeaders action ([wasm-shim#29](https://github.com/Kuadrant/wasm-shim/issues/29))
4. Rate Limiting across clusters ([doc](https://docs.google.com/document/d/1pqCODRAkNUTLB6lJfRWcv3d2Hlj9WqsGySmjrP707Vk/edit#heading=h.nzpgr3pef6uy))

### Highlights

- `spec.rateLimits` replaced with `spec.limits`
- `spec.rateLimits.limits` replaced with `spec.limits.rates`
- `spec.rateLimits.limits.maxValue` replaced with `spec.limits.rates.limit`
- `spec.rateLimits.limits.seconds` replaced with `spec.limits.rates.duration` + `spec.limits.rates.unit`
- `spec.rateLimits.limits.conditions` replaced with `spec.limits.when`, structured field based on _well-known selectors_, mainly for expressing conditions not related to the HTTP route (although not exclusively)
- `spec.rateLimits.limits.variables` replaced with `spec.limits.counters`, based on _well-known selectors_
- `spec.rateLimits.rules` replaced with `spec.limits.rules`, for "sub-targeting" HTTPRouteRules within an HTTPRoute
- `spec.rateLimits.configurations` removed – `spec.rateLimits.configurations.actions` generated from `spec.limits.when.selector` ∪ `spec.limits.counters` and `spec.limits.rules`
- Limitador conditions composed of `spec.limits.when` + unique hash identifier - ensures the limit is enforced only for the targeted HTTPRouteRules

For detailed differences between current and vew RLP API, see [Comparison to current RateLimitPolicy](#comparison-to-current-ratelimitpolicy).

## Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

### Examples of RLPs based on the new API

Given the following network resources:

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: Gateway
metadata:
  name: istio-ingressgateway
  namespace: istio-system
spec:
  gatewayClassName: istio
  listeners:
    - hostname: "*.toystore.com"
---
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: HTTPRoute
metadata:
  name: toystore
  namespace: toystore
spec:
  parentRefs:
    - name: istio-ingressgateway
      namespace: istio-system
  hostnames: ["*.toystore.com"]
  rules:
    - matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
        - path:
            type: PathPrefix
            value: "/toys"
          method: POST
      backendRefs:
        - name: toystore
          port: 80
    - matches:
        - path:
            type: PathPrefix
            value: "/assets/"
      backendRefs:
        - name: toystore
          port: 80
      filters:
        - type: ResponseHeaderModifier
          responseHeaderModifier:
            set:
              - name: Cache-Control
                value: max-age=31536000, immutable
```

The following are examples of RLPs targeting the route and the gateway. Each example is independent from the other.

#### Example 1. Minimal example - network resource targeted entirely without filtering, unconditional and unqualified rate limiting

In this example, all traffic to `*.toystore.com` will be limited to 5rps, unconditionally and regardless of path, method or any other attribute of the request, across all consumers of the API.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-simple-infra-rl
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - rates: # at least one rate limit required
        - limit: 5
          unit: second
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-simple-infra-rl/0/d9edf43707d9a99b4f499055aa59ef6848e2346a638021944bd8f1efce22a8b3" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/toys"},"method":"GET"},{"path":{"type":"PathPrefix","value":"/toys"},"method":"POST"}},{"matches":{"path":{"type":"PathPrefix","value":"/assets/"}}}]
  - rules:
      - paths: ["/assets/*"]
        methods: ["*"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-simple-infra-rl/0/d9edf43707d9a99b4f499055aa59ef6848e2346a638021944bd8f1efce22a8b3" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/toys"},"method":"GET"},{"path":{"type":"PathPrefix","value":"/toys"},"method":"POST"}},{"matches":{"path":{"type":"PathPrefix","value":"/assets/"}}}]
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "toystore/toystore-simple-infra-rl/0/d9edf43707d9a99b4f499055aa59ef6848e2346a638021944bd8f1efce22a8b3"
    max_value: 5
    seconds: 1
    namespace: "*.toystore.com"
  ```
</details>

#### Example 2. Targeting specific route rules, plus conditions, counter qualifiers and multiple rates

In this example, a distinct limit will be associated to each individual rule of the targeted HTTPRoute, using the `rules` field for fine-grained filtering (or "sub-targeting").
- `GET|POST /toys*` → 50rpm, enforced per username (counter qualifier) and only in case the user is not an admin (condition).
- `/assets/*` → 5rpm / 100rp12h

Each rule in the RLP must perfectly match a rule in the HTTPRoute. In case there is no identical match amongst the HTTPRoute rules for a given rule defined in the RLP, the RLP is considered invalid. In case there is more than one rule specified in the RLP that is an identical match to the same rule in the HTTPRoute, the first matching rule on the list in the RLP is bound to its identical match in the HTTPRoute, thus "shadowing" any other rule on the list that is also an identical match.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-per-endpoint
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: toys
      rules:
        - matches: # matches the 1st rule in the HTTPRoute
            - path:
                type: PathPrefix
                value: "/toys"
              method: GET
            - path:
                type: PathPrefix
                value: "/toys"
              method: POST
      rates:
        - limit: 50
          duration: 1
          unit: minute
      counters:
        - auth.identity.username
      when:
        - selector: auth.identity.group
          operator: neq
          value: admin

    - name: assets
      rules:
        - matches: # matches the 2nd rule in the HTTPRoute
            - path:
                type: PathPrefix
                value: "/assets/"
      rates:
        - limit: 5
          duration: 1
          unit: minute
        - limit: 100
          duration: 12
          unit: hour
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-per-endpoint/toys/c7a7782586bc506e89a88d69b2747e52997474bac19bdabe03be2a04fbd9dc0f" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/toys"},"method":"GET"},{"path":{"type":"PathPrefix","value":"/toys"},"method":"POST"}}]
      - metadata:
          descriptor_key: "auth.identity.group"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "group"
      - metadata:
          descriptor_key: "auth.identity.username"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "username"
  - rules:
      - paths: ["/assets/*"]
        methods: ["*"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-per-endpoint/assets/643f8d429ff65b62bf9d69bf201461ce3bf5f47f0a5d54fd519d118fa91cce66" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/assets/"}}}]
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "toystore/toystore-per-endpoint-per-user/toys/c7a7782586bc506e89a88d69b2747e52997474bac19bdabe03be2a04fbd9dc0f"
      - auth.identity.group != "admin"
    variables:
      - auth.identity.username
    max_value: 50
    seconds: 60
    namespace: "*.toystore.com"
  - conditions:
      - context.request.http.route_matcher == "toystore/toystore-per-endpoint-per-user/assets/643f8d429ff65b62bf9d69bf201461ce3bf5f47f0a5d54fd519d118fa91cce66"
    max_value: 5
    seconds: 60
    namespace: "*.toystore.com"
  - conditions:
      - context.request.http.route_matcher == "toystore/toystore-per-endpoint-per-user/assets/643f8d429ff65b62bf9d69bf201461ce3bf5f47f0a5d54fd519d118fa91cce66"
    max_value: 100
    seconds: 43200 # 12 hours
    namespace: "*.toystore.com"
  ```
</details>

#### Example 3. Route filtering using `when` conditions

This is a similar RLP to the one from [Example 2](#example-2-targeting-specific-route-rules-plus-conditions-counter-qualifiers-and-multiple-rates) regarding the use case of applying specific limits to portions of an  HTTPRoute. Whereas in the previous example the route rules map perfectly for the limits to be applied, in this example we use `when` conditions to apply the limit to a subpath without having a corresponding HTTPRouteRule that could be referred using the `rules` field.

`when` conditions are to be used preferably for special cases of conditional filtering based on values other than attributes of the HTTP request that otherwise could be specified using the `rules` field of the RLP. However, in some cases such as where the conditions are not related to the HTTPRoute (e.g. filterring based on hostname, filterring based on metadata) or while the targeted object (HTTPRoute or Gateway) misses the desired rule and cannot be changed, the `when` conditions remain an option.

In this example, a special limit with one rate limit of 150rps is set for `GET /toys/special`. Ideally, an additional HTTPRoute rule would be created and targeted using the `rules` field, with resulting benefits for optimization, status reporting and matching. But because the `toystore` HTTPRoute is unaltered, the special case is implemented using the `when` conditions field instead.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-special-toys
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: read-special
      rules:
        - matches:
            - path:
                type: PathPrefix
                value: "/toys"
              method: GET
            - path: # must be included as well or it wouldn't match the http route rule
                type: PathPrefix
                value: "/toys"
              method: POST
      rates:
        - limit: 150
          unit: second
      when:
        - selector: context.request.http.method
          operator: eq
          value: GET
        - selector: context.request.http.path
          operator: eq
          value: /toys/special
```

By not targeting a specific HTTPRoute rule added for `GET /toys/special`, the rate limit filter (wasm shim) will continue invoking the rate limit service (Limitador) for all requests that match the HTTP the path prefix `/toys` (methods `GET` and `POST`), as targeted HTTPRoute rule. This includes requests to paths other than `GET /toys/special` nevertheless. However, the limit will be ensured to be enforced in Limitador only when the request matches `GET /toys/special`.

Technically, the `rules` field did not have to be included in the RLP, and the `when` would still ensure the limit applies only to requests to `GET /toys/special`. However, in this case the other HTTPRoute rule (`/assets/*`) would also be initally targeted by the limit, though never effectivelly triggered.

On one hand, using `when` conditions for route filterring makes it easy to set limits when either the HTTPRoute cannot be modified to include the special rule or as a shortcut in cases where multiple HTTPRoutes would have to be touched (e.g., when targeting a Gateway with special conditions based on attributes of the HTTP request). On the other hand however, users might miss information in the status in a scenario where the status of rate limiting is reported at the level of the route rule. Effectively, the route rule for `GET|POST /toys*` in the above example might be reported as rate limited to '150rps' with additional details that this is in fact only when requests match `GET /toys/special`.

In the case of existing other limit definitions targeting the `GET|POST /toys*` rule of the `toystore` HTTPRoute, because any merge strategy is expected to take into account the `rules` field as part of the qualification of the limit, all limits are guaranteed to be enforced, and only differenciated by the special "soft" the condition. Nevertheless, to avoid dealing with complex status reports including too many special conditions associated with a limit, **users are encouraged to favor altering the HTTPRoutes for additional route rules in all cases where the rules can be referred in the `rules` field of the RLP, whenever possible**.

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-special-toys/read-special/c7a7782586bc506e89a88d69b2747e52997474bac19bdabe03be2a04fbd9dc0f" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/toys"},"method":"GET"},{"path":{"type":"PathPrefix","value":"/toys"},"method":"POST"}}]
      - request_headers:
          descriptor_key: "context.request.http.path"
          header_name: ":path"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "toystore/toystore-special-toys/read-special/c7a7782586bc506e89a88d69b2747e52997474bac19bdabe03be2a04fbd9dc0f"
      - context.request.http.path == "/toys/special"
    max_value: 150
    seconds: 1
    namespace: "*.toystore.com"
  ```
</details>

#### Example 4. Route filtering by refining the HTTPRoute

To achieve the same goal as stated in [Example 3](#example-3-route-filtering-using-when-conditions), yet ensuring proper merging of conflicting limits that target the same high-level route rule and simpler status report without additional condition details associated with the limit, this example RLP is preceded by a change in the HTTPRoute. A new matching rule is added for the `GET /toys/special` case so it can be targeted by the policy using the `rules` field instead of the `when` conditions field.

New rule added to the HTTPRoute:

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: HTTPRoute
metadata:
  name: toystore
  namespace: toystore
spec:
  parentRefs:
    - name: istio-ingressgateway
      namespace: istio-system
  hostnames: ["*.toystore.com"]
  rules:
    - matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
        - path:
            type: PathPrefix
            value: "/toys"
          method: POST
      backendRefs:
        - name: toystore
          port: 80
    - matches:
        - path:
            type: PathPrefix
            value: "/assets/"
      backendRefs:
        - name: toystore
          port: 80
      filters:
        - type: ResponseHeaderModifier
          responseHeaderModifier:
            set:
              - name: Cache-Control
                value: max-age=31536000, immutable
    - matches: # new rule added so it can be targeted in the RLP
        - path:
            type: Exact
            value: "/toys/special"
          method: GET
      backendRefs:
        - name: toystore
          port: 80
```

RateLimitPolicy:

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-special-toys
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: read-special
      rules:
        - matches:
            - path:
                type: Exact
                value: "/toys/special"
              method: GET
      rates:
        - limit: 150
          unit: second
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys/special"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-special-toys/0/8267df441e5cda729095a9ea78db3abb2420855f7152379b4e88c90b8a4f562e" # SHA256 hashing of [{"matches":{"path":{"type":"Exact","value":"/toys/special"},"method":"GET"}}]
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "toystore/toystore-special-toys/0/8267df441e5cda729095a9ea78db3abb2420855f7152379b4e88c90b8a4f562e"
    max_value: 150
    seconds: 1
    namespace: "*.toystore.com"
  ```
</details>

#### Example 5. One limit, many rules

In this example, both HTTPRoute rules, i.e. `GET|POST /toys*` and `/assets/*`, are targeted by the same limit of 50rpm per username.

Because the HTTPRoute has no other rule, this is technically equivalent to targeting the entire HTTPRoute and therefore similar to [Example 1](#example-1-minimal-example---network-resource-targeted-entirely-without-filtering-unconditional-and-unqualified-rate-limiting). But if the HTTPRoute had other rules or got other rules added afterwards, this would ensure the limit applies only to the two original route rules.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-per-user
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - rules:
        - matches:
            - path:
                type: PathPrefix
                value: "/toys"
              method: GET
            - path:
                type: PathPrefix
                value: "/toys"
              method: POST
        - matches:
            - path:
                type: PathPrefix
                value: "/assets/"
      rates:
        - limit: 50
          duration: 1
          unit: minute
      counters:
        - auth.identity.username
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  ```yaml
  gateway_actions:
  - rules:
      - paths: ["/toys*"]
        methods: ["GET"]
        hosts: ["*.toystore.com"]
      - paths: ["/toys*"]
        methods: ["POST"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-per-user/0/d9edf43707d9a99b4f499055aa59ef6848e2346a638021944bd8f1efce22a8b3" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/toys"},"method":"GET"},{"path":{"type":"PathPrefix","value":"/toys"},"method":"POST"}},{"matches":{"path":{"type":"PathPrefix","value":"/assets/"}}}]
      - metadata:
          descriptor_key: "auth.identity.username"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "username"
  - rules:
      - paths: ["/assets/*"]
        methods: ["*"]
        hosts: ["*.toystore.com"]
    configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-per-user/0/d9edf43707d9a99b4f499055aa59ef6848e2346a638021944bd8f1efce22a8b3" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/toys"},"method":"GET"},{"path":{"type":"PathPrefix","value":"/toys"},"method":"POST"}},{"matches":{"path":{"type":"PathPrefix","value":"/assets/"}}}]
      - metadata:
          descriptor_key: "auth.identity.username"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "username"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "toystore/toystore-per-user/0/d9edf43707d9a99b4f499055aa59ef6848e2346a638021944bd8f1efce22a8b3"
    variables:
      - auth.identity.username
    max_value: 50
    seconds: 60
    namespace: "*.toystore.com"
  ```
</details>

#### Example 6. Targeting the Gateway

> **Note:** Additional meaning and context may be given to this use case in the future, when discussing [defaults and overrides](https://gateway-api.sigs.k8s.io/references/policy-attachment/#hierarchy).

Targeting a Gateway is a shortcut to targeting all individual HTTPRoutes referencing to the gateway as parent, without any filtering based on the `rules` field.

This differs from [Example 1](#example-1-minimal-example---network-resource-targeted-entirely-without-filtering-unconditional-and-unqualified-rate-limiting) because, by targeting the gateway rather than an individual HTTPRoute, the RLP applies automatically to all HTTPRoutes pointing to the gateway, including routes created before and after the creation of the RLP. Moreover, all those routes will share the same limit counters specified in the RLP.

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-simple-infra-rl
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: Gateway
    name: istio-ingressgateway
  limits:
    - rates:
        - limit: 5
          unit: second
```

<details>
  <summary><sub>How is this RLP implemented under the hood?</sub></summary>

  Because there is no matcher in the Gateway, this limit rather have to define a generic key descriptor that is valid for all routes – i.e. without the [artificial Limitador condition](#artificial-limitador-condition-for-rules) associated with the `rules` field, such as one that identifies the RLP only.

  ```yaml
  gateway_actions:
  - configurations:
      - generic_key:
          descriptor_key: "context.request.http.route_matcher"
          descriptor_value: "toystore/toystore-simple-infra-rl"
  ```

  ```yaml
  limits:
  - conditions:
      - context.request.http.route_matcher == "toystore/toystore-simple-infra-rl"
    max_value: 5
    seconds: 1
    namespace: "*.toystore.com"
  ```
</details>

### Comparison to current RateLimitPolicy

<table>
  <thead>
    <tr>
      <th>Current</th>
      <th>New</th>
      <th>Reason</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1:1 relation between <i>Limit</i> (the object) and the actual <i>Rate limit</i> (the value) (<code>spec.rateLimits.limits</code>)</td>
      <td><i>Rate limit</i> becomes a detail of <i>Limit</i> where each limit may define one or more rates (1:N) (<code>spec.limits.rates</code>)</td>
      <td>
        <ul>
          <li>It allows to reuse <code>when</code> conditions and <code>counters</code> for <i>groups of rate limits</i></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Parsed <code>spec.rateLimits.limits.conditions</code> field, directly exposing the Limitador's API</td>
      <td>Structured <code>spec.limits.when</code> condition field composed of 3 well-defined properties: <code>selector</code>, <code>operator</code> and <code>value</code></td>
      <td>
        <ul>
          <li>Feels more K8s-native</li>
          <li>Consistent with <a href="https://pkg.go.dev/github.com/kuadrant/authorino/api/v1beta1#JSONPatternExpression">github.com/kuadrant/authorino/api/v1beta1#JSONPatternExpression</a></li>
          <li>No need for a parser (only if implemented by Limitador)</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.configurations</code> as a list of "variables assignments" and direct exposure of <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter#composing-actions">Envoy's RL descriptor actions API</a></td>
      <td>Descriptor actions composed implicitly from selectors used in the limit definitions (<code>spec.limits.when.selector</code> and <code>spec.limits.counters</code>) plus a fixed identifier of the route rules (<code>spec.limits.rules</code>)</td>
      <td>
        <ul>
          <li>Abstract the Envoy-specific concepts of "actions" and "descriptors"</li>
          <li>No risk of mismatching descriptors keys between "actions" and actual usage in the limits</li>
          <li>No user-defined generic descriptors (e.g. "limited = 1")</li>
          <li>Source value of the selectors defined from an implicit "context" data structure</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Key-value descriptors</td>
      <td>Structured descriptors referring to a contextual well-known data structure</td>
      <td>
        <ul>
          <li>Consistent with Authorino's <a href="https://github.com/Kuadrant/authorino/blob/main/docs/architecture.md#the-authorization-json">Authorization JSON (#context)</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Limitador conditions independent from the route rules</td>
      <td>Artificial Limitador condition injected for each route rule</td>
      <td>
        <ul>
          <li>Ensure the limit is enforced only for corresponding filtered HTTPRouteRule</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.rules ⊆ httproute.spec.rules</code></a></td>
      <td><code>spec.limits.rules.matches == httproute.spec.rules.matches</code></td>
      <td>
        <ul>
          <li>Perfect match to HTTPRoute rules</li>
          <li>Simpler to solve for defaults and overrides</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.limits.seconds</code></td>
      <td><code>spec.limits.rates.duration</code> and <code>spec.limits.rates.unit</code></td>
      <td>
        <ul>
          <li>Support for more units beyond seconds</li>
          <li><code>duration: 1</code> by default</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.limits.variables</code></td>
      <td><code>spec.limits.counters</code></td>
      <td>
        <ul>
          <li>Less generic naming</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>spec.rateLimits.limits.maxValue</code></td>
      <td><code>spec.limits.rates.limit</code></td>
      <td>
        <ul>
          <li>More generic naming</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

## Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

By completely dropping out the `configurations` field from the RLP, [composing the RL descriptor actions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter#composing-actions) is now done based essentially on the selectors listed in the `when` conditions and the `counters`, plus artificial generic conditions used to match the specific route rule (when the `rules` is non-empty or implicit).

### Well-known selectors

Each selector is a direct reference to a path within a well-known data structure that holds the `context` (L4 and L7 data of the original request handled by the proxy), as well as occasionally the `auth` data (dynamic metadata exported by the external authorization filter and injected by the proxy into the rate-limit filter).

The well-known data structure for building RL descriptor actions resembles Authorino's ["Authorization JSON"](https://github.com/Kuadrant/authorino/blob/main/docs/architecture.md#the-authorization-json), whose `context` component consists of Envoy's [`AttributeContext`](https://pkg.go.dev/github.com/envoyproxy/go-control-plane/envoy/service/auth/v3?utm_source=gopls#AttributeContext) type of the external authorization API, marshalled as JSON. Compared to the more generic [`RateLimitRequest`](https://pkg.go.dev/github.com/envoyproxy/go-control-plane@v0.11.0/envoy/service/ratelimit/v3#RateLimitRequest) struct, the `AttributeContext` provides a more structured and arguibly more intuitive relation between the data sources for the RL descriptors actions and their corresponding key names through which the values are referred within the RLP, in a context of serving predominantly for HTTP-based APIs.

To keep compatibility with the [Envoy Rate Limit API](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter), the well-known data structure can optionally be extended with the `RateLimitRequest`, thus resulting in the following final structure.

```yaml
context: # Envoy's Ext-Authz `CheckRequest.AttributeContext` type
  source:
    address: …
    service: …
    …
  destination:
    address: …
    service: …
    …
  request:
    http:
      host: …
      path: …
      method: …
      headers: {…}

auth: # Dynamic metadata exported by the external authorization service

ratelimit: # Envoy's Rate Limit `RateLimitRequest` type
  domain: … # generated by the Kuadrant controller
  descriptors: {…} # descriptors configured by the user directly in the proxy (not generated by the Kuadrant controller, if allowed)
  hitsAddend: … # only in case we want to allow users to refer to this value in a policy
```

### Mechanics of generating RL descriptor actions

From the perspective of a user who writes a RLP, the selectors used in then `when` and `counters` fields are paths to the well-known data structure ([_well-known selectors_](#well-known-selectors)). While desiging a policy, the user intuitively pictures the well-known data structure and designs each rule (each limit) thinking on the possible values assumed by each of those paths in the data plane. For example,

The user story:
> _Whenever the context is an HTTP request sent to `dolls.toystore.com` hostname (`context.request.http.host`), I want a rate limit of 50 rps per distinct user (`auth.identity.username`)._

...materializes as the following RLP:

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: toys-path
      when:
        - selector: context.request.http.host
          operator: eq
          value: dolls.toystore.com
      rates:
        - limit: 50
          duration: 1
          unit: second
      counters:
        - auth.identity.username
```

The following selectors are to be interpreted by the RLP controller:
- `context.request.http.host`
- `auth.identity.username`

The RLP controller uses a map to translate each selector into its corresponding descriptor action. (Roughly described:)

```
context.source.address    → source_cluster(...) # TBC
context.source.service    → source_cluster(...) # TBC
context.destination...    → destination_cluster(...)
context.destination...    → destination_cluster(...)
context.request.http.<X>  → request_headers(header_name: ":<X>")
context.request...        → ...
auth.<X>                  → metadata(key: "envoy.filters.http.ext_authz", path: <X>)
ratelimit.domain          → <hostname>
```

...to yield effectively:

```yaml
rate_limits:
  - actions:
      - request_headers:
          descriptor_key: "context.request.http.host"
          header_name: ":authority"
      - metadata:
          descriptor_key: "auth.identity.username"
          metadata_key:
            key: "envoy.filters.http.ext_authz"
            path:
              - segment:
                  key: "identity"
              - segment:
                  key: "username"
```

### Artificial Limitador condition for `rules`

For each limit with non-empty (or implicit) `rules` field, the RLP controller will generate an artificial Limitador condition that ensures that the limit applies only when the filterred rules are honoured when serving the request. This can be implemented with a 2-step procedure:
1. generate an unique identifier for the limit – e.g. by applying any sufficiently entropic hash function of choice to the `rules` block of the limit;
2. associate a `generic_key` type descriptor action to the each `HTTPRouteRule` targeted by the limit.

For example, given the following RLP:

```yaml
apiVersion: kuadrant.io/v2beta1
kind: RateLimitPolicy
metadata:
  name: toystore-non-admin-users
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: HTTPRoute
    name: toystore
  limits:
    - name: toys
      matches:
        - path:
            type: PathPrefix
            value: "/toys"
          method: GET
        - path:
            type: PathPrefix
            value: "/toys"
          method: POST
      rates:
        - limit: 50
          duration: 1
          unit: minute
      when:
        - selector: auth.identity.group
          operator: neq
          value: admin

    - name: assets
      matches:
        - path:
            type: PathPrefix
            value: "/assets/"
      rates:
        - limit: 5
          duration: 1
          unit: minute
      when:
        - selector: auth.identity.group
          operator: neq
          value: admin
```

Apart from the following descriptor action associated with both routes:

```yaml
- metadata:
    descriptor_key: "auth.identity.group"
    metadata_key:
      key: "envoy.filters.http.ext_authz"
      path:
        - segment:
            key: "identity"
        - segment:
            key: "group"
```

...and its corresponding Limitador condition:

```
auth.identity.group != "admin"
```

The following additional artificial descriptor actions will be generated:

```yaml
# associated with route rule GET|POST /toys*
- generic_key:
    descriptor_key: "context.request.http.route_matcher"
    descriptor_value: "c7a7782586bc506e89a88d69b2747e52997474bac19bdabe03be2a04fbd9dc0f" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/toys"},"method":"GET"},{"path":{"type":"PathPrefix","value":"/toys"},"method":"POST"}}]

# associated with route rule /assets/*
- generic_key:
    descriptor_key: "context.request.http.route_matcher"
    descriptor_value: "643f8d429ff65b62bf9d69bf201461ce3bf5f47f0a5d54fd519d118fa91cce66" # SHA256 hashing of [{"matches":{"path":{"type":"PathPrefix","value":"/assets/"}}}]
```

...and their corresponding Limitador conditions.

In the end, the following Limitador configuration is yielded:

```yaml
- conditions:
    - context.request.http.route_matcher == "c7a7782586bc506e89a88d69b2747e52997474bac19bdabe03be2a04fbd9dc0f"
    - auth.identity.group != "admin"
  max_value: 50
  seconds: 60
  namespace: "*.toystore.com"

- conditions:
    - context.request.http.route_matcher == "643f8d429ff65b62bf9d69bf201461ce3bf5f47f0a5d54fd519d118fa91cce66"
    - auth.identity.group != "admin"
  max_value: 5
  seconds: 60
  namespace: "*.toystore.com"
```

The limit-to-route rule matcher identifiers can be qualified with a plain identifier of the RLP itself (`namespace/name`) and the limit where it is defined (`name` of the limit when available, index in the array of limits otherwise), thus making the identifier unique to the scope of the entire cluster.

E.g.: the two unique identifiers from above, prefixed with the unique limit qualifier, become respectively `toystore/toystore-non-admin-users/toys/c7a7782586bc506e89a88d69b2747e52997474bac19bdabe03be2a04fbd9dc0f` and `toystore/toystore-non-admin-users/assets/643f8d429ff65b62bf9d69bf201461ce3bf5f47f0a5d54fd519d118fa91cce66`.

This has a consequence to the readability of the identifier, but also and more importantly it ensures uniqueness of the counters in Limitador. By qualifying (or salting) the identifiers, two limits or two RLPs that happen to target the same HTTPRouteRules will not register the same counters in Limitador, but be treated as independent ones instead.

### Support in wasm shim and Envoy RL API

This proposal tries to keep compatibility with the [Envoy API for rate limit](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter) and does not introduce any new requirement that otherwise would require the use of [wasm shim](https://github.com/Kuadrant/wasm-shim) to be implemented.

In the case of implementation of this proposal in the wasm shim, all types of matchers supported by the [HTTPRouteMatch](https://gateway-api.sigs.k8s.io/references/spec/#gateway.networking.k8s.io/v1beta1.HTTPRouteMatch) type of Gateway API must be also supported in the `rate_limit_policies.gateway_actions.rules` field of the [wasm plugin configuration](https://github.com/Kuadrant/kuadrant-operator/blob/faf41ff6b08df27946a663c34a5736476578dea5/pkg/rlptools/wasm_utils.go#L109). These include matchers based on path (prefix, exact), headers, query string parameters and method.

## Drawbacks
[drawbacks]: #drawbacks

**Two types of conditions – `rules` and `when` conditions**<br/>
Although with different meanings (evaluates in the gateway vs. evaluated in Limitador) and capable of expressing different sets of rules (HTTPRouteRule-targeting rules vs. HTTP request-related and non HTTP request-related "soft" conditions), an overlap between these two types and ways of representing conditions does exist.

**Prone to consistency issues**<br/>
Typos and updates to the HTTPRoute can easily cause a mismatch and invalidate a RLP.

## Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

### Possible variations for the selectors (conditions and counter qualifiers)

The main drivers behind the proposed design for the selectors (conditions and counter qualifiers), based on (i) structured condition expressions composed of fields `selector`, `operator`, and `value`, and (ii) `when` conditions and `counters` separated in two distinct fields (variation "C" below), are:
1. consistency with the Authorino `AuthConfig` API, which also specifies [`when`](https://github.com/Kuadrant/authorino/blob/main/docs/features.md#common-feature-conditions-when) conditions expressed in `selector`, `operator`, and `value` fields;
2. explicit user intent, without subtle distinction of meaning based on presence of optional fields.

Nonetheless here are a few alternative variations to consider:

<table>
  <thead>
    <tr>
      <th></th>
      <th>Structured condition expressions</th>
      <th>Parsed condition expressions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Single field</th>
      <td>
        <b>A</b>
        <pre>
selectors:
  - selector: context.request.http.method
    operator: eq
    value: GET
  - selector: auth.identity.username</pre>
      </td>
      <td>
        <b>B</b>
        <pre>
selectors:
  - context.request.http.method == "GET"
  - auth.identity.username</pre>
      </td>
    </tr>
    <tr>
      <th>Distinct fields</th>
      <td>
        <b>C <sup>⭐️</sup></b>
        <pre>
when:
  - selector: context.request.http.method
    operator: eq
    value: GET
counters:
  - auth.identity.username</pre>
      </td>
      <td>
        <b>D</b>
        <pre>
when:
  - context.request.http.method == "GET"
counters:
  - auth.identity.username</pre>
      </td>
    </tr>
  </tbody>
</table>

<sup>⭐️ Variation adopted for the <a href="#examples-of-rlps-based-on-the-new-api">examples</a> and (so far) final design proposal.</sup>

## Prior art
[prior-art]: #prior-art

Most implementations currently orbiting around Gateway API (e.g. Istio, Envoy Gateway, etc) for added RL functionality seem to have been leaning more to the direct route extension pattern instead of Policy Attachment. That might be an option particularly suitable for gateway implementations (gateway providers) and for those aiming to avoid dealing with defaults and overrides.

## Unresolved questions
[unresolved-questions]: #unresolved-questions

1. What does this mean with _defaults_ and _overrides_?
2. Do we need anything here that points to shared counters across clusters/Limitador instances or does that belong to different layer (`Limitador`, `Kuadrant` CRDs, MCTC)?
3. What condition `operator`s do we need (e.g. `eq`, `neq`, `exists`, `nexists`, `matches`)?

## Future possibilities
[future-possibilities]: #future-possibilities

- Port `rules` and the semantics around it to the `AuthPolicy` API (aka "KAP v2").
- Defaults and overrides, either along the lines of [architecture#4](https://github.com/Kuadrant/architecture/pull/4) or [architecture#10](https://github.com/Kuadrant/architecture/pull/10).
